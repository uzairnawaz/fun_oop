- Write a fun program that runs in 10 seconds when using your fun interpreter
  from p2. Please don't commit it. Run the compiled version from p4, how long
  does it take to run?

The stress test I wrote takes about 10 seconds to run on my p2 interpreter. But, passing the fun
file into my compiler causes it to execute in just ~1.6 seconds, which is a major improvement. One
thing to also note is that this compiler is compiling to ARM machine code, which is then being
emulated. If this program was executed on an ARM machine with similar specs, we would see an even
larger improvement.

- Why does compiled code run faster than interpreted code?
Compiled code is generally executed directly by the hardware. This means that there aren't any
layers of abstraction or translations taking place when the code is executing, the hardware simply
process the bits and generates the resulting output through physical circuits. In interpreted code,
there is a layer of abstraction between the code and the hardware. This layer causes delays in the
execution, making it slower than compiled code.

- Does your code run as fast as it could? What is slowing it down?
This program could definitely be executing even faster than it currently is due to 2 main factors.
One reason is the fact that the ARM machine code is being emulated, rather than being run natively
on an ARM architecture. This means that for every ARM instruction in the binary file, qemu (the 
emulator) has to determine the corresponding x86 machine code to execute so that the program
executes as expected. This layer causes the program to run slower than it could be.

Another issue is found in the machine code itself. The compiler I wrote isn't perfect. There are
many places where there are obvious redundancies that even a human could spot (like storing a 
register into memory only to load it back into a register immediately). Creating more optimized
machine code would allow it to run faster as there are less instructions that need to be executed.

- What is emulator? Use your words and give examples
An emulator is a program that mimics the execution of another system. For example, in this project,
we use qemu to execute our ARM machine code that our compiler produces. However, the system that I 
am currently running on is x86. Qemu allows me to still execute ARM binaries by copying the behavior
that an ARM machine would have when executing ARM machine code. 

- What is a cross-compiler? Use your words and give examples
A cross-compiler is a compiler that compiles code into a machine language that isn't native to the
architecture that the compiler is running on. This fun compiler is an example of a cross-compiler.
It is a program that runs on x86 architecture that converts fun code into ARM machine code. This
machine code can't be directly executed on the same system that the compiler was executed on without
the use of an emulator.

- What is a tool-chain? Use your words and give examples
A tool-chain is simply a chain of tools that is used to execute a program. One tool is used to
generate the input to the next tool and so on until an executable program is created. In this
project, our toolchain started with the fun compiler that we wrote. This program took fun code and
converted it into ARM assembly. The next tool in the chain was the assembler, which converted the
ARM assembly into ARM machine code, which could then be executed by an ARM system or an emulator
like qemu. 

- Why did I add the "argc" requirement in this assignment?

The "argc" requirement ensures that the program doesn't have all the necessary information
to run at compile-time. If this was the case, then a clever compiler could simply interpret
the entire program and create an executable that would simply print out a string containing the
correct output. Forcing the program to accept an input at runtime forces us to write machine code
that actually does process the input and compute the correct output for any given value of argc.

